import cligen
import system
import os
import std/sysrand

#[
    Fills and populates an array of a given size with default values
    @params: value of any type, and size of BiggestInt
    @return: An array of given size and any type (generic type, T)
]#
proc fill[T](value: T, size: BiggestInt): seq[T] =
    result = newSeq[T](size)
    for item in result.mitems:
        item = value

#[
    Generates random bytes
    @params: file size of BiggestInt type
    @return: sequence of random bytes
]#
proc random(size: BiggestInt): seq[byte] =
    result = urandom(size)

#[
    Write generated bytes to file and ensure all file content has been overwritten
    @params: Takes array with bytes and string for absolute file path
    @return: bool to indicate success
]#
proc write_file(bytes_array: openArray[int8 | uint8], file_path: string): bool =
    var file = open(file_path, fmReadWriteExisting)
    var file_size = getFileSize(file)
    var bytes_written: int = writeBytes(file, bytes_array, 0, len(bytes_array)) # Returns num of actual written bytes, may be less due to error
    close(file)
    if bytes_written != file_size:
        return false
    return true

#[
    Calls made to generate data and write to file a specified number of times, and deletes file at the end
    @params: file path in string, and number of passes in int
    @returns: bool to indicate success or failure
    @docs: https://github.com/c-blake/cligen/blob/master/test/UserError.nim
]#
proc overwrite(file_path: string, passes: int): bool =
    ## Get file size
    var file_size = getFileSize(file_path) 

    ## Generate content with exact size
    var all_zeroes = fill(byte(0), file_size)
    var all_ones = fill(byte 0x11, file_size)
    var random_bytes = random(file_size)
    
    ## Write to file * number of passes
    var isZero: bool
    var isOne: bool
    var isRandom: bool
    for i in 1..passes:
        isZero = write_file(toOpenArray(all_zeroes, 0, len(all_zeroes) - 1), file_path)
        isOne = write_file(toOpenArray(all_ones, 0, len(all_ones) - 1), file_path)
        isRandom = write_file(toOpenArray(random_bytes, 0, len(random_bytes) - 1), file_path)

    ## Delete file
    var isDelete: bool
    if isZero and isOne and isRandom:
        isDelete = tryRemoveFile(file_path)
    return isDelete

# Expecting "
#[
    Function for cligen, and it expects "shredder -p 123 some-string" as user input.
    Handles user input arguments through shell
    @params: passes of int, and filename as seq of string
    @docs: https://c-blake.github.io/cligen/cligen.html
]#
proc shredder(passes=1, filename: seq[string]) =
    if filename.len < 1:
        raise newException(HelpError, "Too few arguments, refer to ${HELP}")
    var success: bool = overwrite(filename[0], passes)
    if success:
        echo "File shredding succeeded with ", passes, " passes written to file at ", filename[0]
        echo "Your file has now been safely erased from the drive."
    else:
        echo "File shredding operation has failed, please try again."

when isMainModule:
    clCfg.hTabCols = @[clOptKeys, clDescrip] # Only display these two cols and omit the param type/val
    clCfg = ClCfg(version: "1.0.0",
                  hTabCols: @[clOptKeys, clDescrip],
                  hTabColGap: 2,
                  hTabSuppress: "CLIGEN-NOHELP")
    dispatch(shredder, 
            help = {"help": "print this help message", "passes": "number of times to overwrite/shred"},
            short = { "version": 'v'})